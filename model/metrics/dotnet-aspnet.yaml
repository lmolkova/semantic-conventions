groups:
  - id: aspnet
    prefix: aspnet
    type: attribute_group
    brief: ASP.NET Core attributes
    attributes:
      - id: rate_limiting.policy
        type: string
        brief: TODO
        examples: ["TODO"]
      - id: rate_limiting.reject_reason
        type: string
        brief: TODO
        examples: ["TODO"]
        note: "**TODO should it be an enum?**"
      - id: routing.fallback
        type: string
        brief: TODO
        examples: ["TODO"]
      - id: handler
        type: string
        brief: TODO
        examples: ["TODO"]

  # misc
  - id: metric.aspnet.server.unhandled_requests
    type: metric
    metric_name: http.server.unhandled_requests
    brief: Number of requests that reached the end of the middleware pipeline without being handled by application code.
    instrument: updowncounter
    unit: "{request}"
    note: |
      Meter name is `Microsoft.AspNetCore.Hosting`.
      **TODO Any reason not to put it into aspnet? seems ASP.NET -specific (middleware, app code), not necessarily HTTP?**

  # routing
  - id: metric.aspnet.routing.successful_matches
    type: metric
    metric_name: aspnet.routing.successful_matches
    brief: Number of requests that successfully matched to an endpoint.
    instrument: counter
    unit: "{match}"
    note: >
     Meter name is `Microsoft.AspNetCore.Routing`.
    attributes:
      - ref: http.route
        requirement_level: required
      - ref: aspnet.routing.fallback
        requirement_level: required

  - id: metric.aspnet.routing.failed_matches
    type: metric
    metric_name: aspnet.routing.failed_matches
    brief: Number of requests that failed to match to an endpoint.
    note: >
      An unmatched request may be handled by later middleware, such as the static files or authentication middleware.
      Meter name is `Microsoft.AspNetCore.Routing`
    instrument: counter
    unit: "{match}"

  # diagnostics
  - id: metric.aspnet.diagnostics_handler.exceptions
    type: metric
    metric_name: aspnet.diagnostics_handler.exceptions
    brief: Number of exceptions caught by exception handling middleware.
    instrument: counter
    unit: "{exception}"
    note: Meter name is `Microsoft.AspNetCore.Diagnostics`
    attributes:
      - ref: exception.type
      - ref: aspnet.handler
        requirement_level: required
      - id: exception.result
        type: string
        requirement_level: required
        brief: TODO
        examples: ["TODO"]

  # rate_limiting
  - id: metric.aspnet.rate_limiting.active_request_leases
    type: metric
    metric_name: aspnet.rate_limiting.active_request_leases
    brief: Number of requests that are currently active on the server that hold a rate limiting lease.
    instrument: updowncounter
    unit: "{request}"
    note: Meter name is `Microsoft.AspNetCore.RateLimiting`
    attributes:
      - ref: aspnet.rate_limiting.policy
        requirement_level: required

  - id: metric.aspnet.rate_limiting.request_lease.duration
    type: metric
    metric_name: aspnet.rate_limiting.request_lease.duration
    brief: The duration of rate limiting lease held by requests on the server.
    instrument: histogram
    unit: "s"
    note: |
      Meter name is `Microsoft.AspNetCore.RateLimiting`
      **TODO do we need attributes?, can we explain what it means better**`

  - id: metric.aspnet.rate_limiting.queued_request.duration
    type: metric
    metric_name: aspnet.rate_limiting.queued_request.duration
    brief: The duration of request in a queue, waiting to acquire a rate limiting lease.
    instrument: histogram
    unit: "s"
    note: |
      Meter name is `Microsoft.AspNetCore.RateLimiting`

      **TODO: I don't really understand what this duration is, can we improve name, brief or description to explain? **
      **TODO: if they are queued, should they have reject reason ? **
    attributes:
      - ref: aspnet.rate_limiting.policy
        requirement_level: required

  - id: metric.aspnet.rate_limiting.queued_requests
    type: metric
    metric_name: aspnet.rate_limiting.queued_requests
    brief: Number of requests that are currently queued, waiting to acquire a rate limiting lease.
    instrument: updowncounter
    unit: "{request}"
    note: |
      Meter name is `Microsoft.AspNetCore.RateLimiting`

      **TODO: if they are queued, should they have reject reason ? **
    attributes:
      - ref: aspnet.rate_limiting.policy
        requirement_level: required
      - ref: aspnet.rate_limiting.reject_reason

  - id: metric.aspnet.rate_limiting.rejected_requests
    type: metric
    metric_name: aspnet.rate_limiting.rejected_requests
    brief: Number of requests that failed to acquire a rate limiting lease.
    instrument: counter
    unit: "{request}"
    note: |
      Requests could be rejected by global or endpoint rate limiting policies. Or the request could be cancelled while waiting for the lease.

      Meter name is `Microsoft.AspNetCore.RateLimiting`

      **TODO: can we report aspnet.rate_limiting.request count instead and have reject_reason to count failed/successful ?**
    attributes:
      - ref: aspnet.rate_limiting.policy
        requirement_level: required
      - ref: aspnet.rate_limiting.reject_reason
